#!/usr/bin/env python3
import os
import time
import socket
import sys
import platform
import subprocess
import asyncio
from datetime import datetime
from pathlib import Path

# Try to import Bluetooth modules
try:
    import bluetooth
    CLASSIC_BT_AVAILABLE = True
except ImportError:
    CLASSIC_BT_AVAILABLE = False

try:
    from bleak import BleakScanner, BleakClient
    BLE_AVAILABLE = True
except ImportError:
    BLE_AVAILABLE = False

# Color codes
GREEN = '\033[32m'
YELLOW = '\033[33m'
RED = '\033[31m'
BLUE = '\033[34m'
MAGENTA = '\033[35m'
CYAN = '\033[36m'
LIGHTCYAN_EX = '\033[96m'
BLACK = '\x1b[30m'
RESET = '\033[0m'

# Configuration
ANIMATION_SPEED = 0.005

### Color Status ###
def print_status(message: str) -> None:
    """Print status messages"""
    print(f"{GREEN}[+]{RESET} {message}")

def print_warning(message: str) -> None:
    """Print warning messages"""
    print(f"{YELLOW}[!]{RESET} {message}")

def print_error(message: str) -> None:
    """Print error messages"""
    print(f"{RED}[-]{RESET} {message}")

### Text Animation ###
def text_animation():
    banner_text = f"""{MAGENTA}
 _  _  _   _    __    ____  _  _  ____  ___  ____  ____  ____ {RED}
( \/ )( )_( )  /__\  (  _ \( \/ )( ___)/ __)(_  _)( ___)(  _ \\{MAGENTA}
 )  (  ) _ (  /(__)\  )   / \  /  )__) \__ \  )(   )__)  )   /{RED}
(_/\_)(_) (_)(__)(__)(_)\_)  \/  (____)(___/ (__) (____)(_)\_)
    {RESET}"""
    for char in banner_text:
        print(char, end='', flush=True)
        time.sleep(ANIMATION_SPEED)
    print(f"\n{CYAN}>>> Extended Reconnaissance Toolkit For Pentesters <<<{RESET}")
    print(f"{GREEN}| GitHub:{RESET}{YELLOW} @n3tworkh4x |{RESET}{MAGENTA} Ko-fi{YELLOW}(Donation):{RESET}{GREEN} https://ko-fi.com/n3twork |")
    print(f"\t\t\t{RED}DEVELOPED{YELLOW} BY{GREEN} N3TWORK({RED}G{YELLOW}H{GREEN}A{BLACK}N{RED}A)\t\t\t")
    print(f"{RED} Use only for authorized security testing!{RESET}")

### Display Menu ###
def show_menu() -> None:
    text_animation()
    print(f"\n\t\t\t(▀̿Ĺ̯▀̿ ̿)\t\t\t\n")
    print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
    print(f"{GREEN}         🚀   XHARVESTER -- MAIN MENU")
    print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
    print(f"{CYAN}\t[1] 🔀 BlueTooth")
    print(f"{CYAN}\t[2] 📶 Wifi")
    print(f"{CYAN}\t[3] 🚖 Automobile")
    print(f"{CYAN}\t[4] 📡 Radio Frequency")
    print(f"{CYAN}\t[5] 🏙️  Industrial Control System - SCADA")
    print(f"{CYAN}\t[6] 🤘 About")
    print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
    print(f"{RED}\t [0] ❌ Exit")
    print(f"{YELLOW}\t[99] 🎁 Update XHARVESTER")
    print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")  

### Display About ###
def about() -> None:
    description = f"""
{RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{YELLOW}Bio: {RESET}{GREEN}I am a 19-year-old skilled hacker and programmer with expertise in ICS/SCADA security,
{GREEN}Wireless exploitation (Wi-Fi/Bluetooth/RF) & Automotive systems hacking.
{RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{YELLOW}About: {RESET}{CYAN}xharvester is a specialized,{RESET}
{CYAN}modular Python-based reconnaissance suite designed for security assessments of radio frequency (RF),{RESET}
{CYAN}wireless (bluetooth & wifi),{RESET}
{CYAN}industrial control system (SCADA),{RESET}
{CYAN}and automotive systems.{RESET}
{CYAN}It integrates multiple tools and scripts into a unified workflow for probing,{RESET}
{CYAN}analyzing, and documenting findings from the physical and wireless world.{RESET}
{RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
{YELLOW}Version: {RESET}{BLUE}1.0.0{RESET}
{YELLOW}Time: {RESET}{BLUE}{datetime.now()}{RESET}
{RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""
    
    print(description)

### Clear screen function with platform detection ###
def clear_screen() -> None:
    """Clear the terminal screen based on the operating system"""
    os.system('cls' if os.name == 'nt' else 'clear')

### Get hostname with error handling ###
def get_hostname() -> str:
    """Get hostname with proper error handling"""
    try:
        return socket.gethostname()
    except:
        return "unknown"

### Check for root privileges ###
def check_root() -> bool:
    """Check if the script is running with root privileges"""
    if platform.system() == "Windows":
        # On Windows, we need to check for administrator privileges
        try:
            import ctypes
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        except:
            return False
    else:
        # On Unix-like systems, check for root UID
        return os.geteuid() == 0

### Check if desktop launcher exists ###
def check_desktop_launcher() -> bool:
    """Check if desktop launcher exists and is accessible"""
    system = platform.system().lower()
    
    if system == "windows":
        # Check for Windows shortcut
        desktop = Path.home() / "Desktop" / "XHarvester.lnk"
        if desktop.exists():
            return True
        
        # Check other possible locations
        possible_locations = [
            Path.home() / "OneDrive" / "Desktop" / "XHarvester.lnk",
            Path(os.environ.get('USERPROFILE', '')) / "Desktop" / "XHarvester.lnk"
        ]
        
        for location in possible_locations:
            if location.exists():
                return True
                
    else:
        # Check for Linux desktop launcher
        desktop_file = Path.home() / ".local" / "share" / "applications" / "xharvester.desktop"
        if desktop_file.exists():
            return True
    
    return False

### Fix desktop launcher permissions ###
def fix_desktop_launcher():
    """Fix desktop launcher permissions and accessibility"""
    system = platform.system().lower()
    
    if system != "windows":
        # For Linux systems, ensure the desktop file is executable
        desktop_file = Path.home() / ".local" / "share" / "applications" / "xharvester.desktop"
        if desktop_file.exists():
            try:
                desktop_file.chmod(desktop_file.stat().st_mode | 0o755)
                print_status("Fixed desktop launcher permissions")
                return True
            except Exception as e:
                print_error(f"Failed to fix desktop launcher permissions: {e}")
                return False
    return False

### Bluetooth Functions ###
def check_bluetooth_dependencies():
    """Check if Bluetooth dependencies are available"""
    if not CLASSIC_BT_AVAILABLE:
        print_error("PyBluez not available for classic Bluetooth")
        print_warning("Install with: pip install pybluez2")
    
    if not BLE_AVAILABLE:
        print_error("Bleak not available for BLE")
        print_warning("Install with: pip install bleak")
    
    return CLASSIC_BT_AVAILABLE or BLE_AVAILABLE

def discover_classic_devices():
    """Discover classic Bluetooth devices"""
    if not CLASSIC_BT_AVAILABLE:
        return []
    
    try:
        print_status("Scanning for classic Bluetooth devices (this may take 10-15 seconds)...")
        devices = bluetooth.discover_devices(lookup_names=True, duration=10, flush_cache=True)
        return devices
    except Exception as e:
        print_error(f"Classic Bluetooth discovery failed: {e}")
        return []

async def discover_ble_devices():
    """Discover BLE devices"""
    if not BLE_AVAILABLE:
        return []
    
    try:
        print_status("Scanning for BLE devices...")
        devices = await BleakScanner.discover(timeout=10.0)
        return devices
    except Exception as e:
        print_error(f"BLE discovery failed: {e}")
        return []

def list_services(address):
    """List services for a Bluetooth device"""
    if not CLASSIC_BT_AVAILABLE:
        print_error("PyBluez not available")
        return
    
    try:
        print_status(f"Discovering services for {address}...")
        services = bluetooth.find_service(address=address)
        
        if not services:
            print_warning("No services found")
            return
        
        for service in services:
            print(f"{CYAN}Service: {service['name']}")
            print(f"  Host: {service['host']}")
            print(f"  Description: {service['description']}")
            print(f"  Provider: {service['provider']}")
            print(f"  Protocol: {service['protocol']}")
            print(f"  Port: {service['port']}")
            print(f"  Service ID: {service['service-id']}{RESET}")
            print()
            
    except Exception as e:
        print_error(f"Service discovery failed: {e}")

def bluejacking_demo(target_name="Phone"):
    """Demo of bluejacking concept"""
    print_status("Bluejacking Demo")
    print(f"{YELLOW}Bluejacking involves sending unsolicited messages to Bluetooth devices.")
    print(f"This is a demonstration of the concept - not an actual attack.{RESET}")
    print()
    
    # Discover devices
    devices = discover_classic_devices()
    
    if not devices:
        print_warning("No devices found for bluejacking demo")
        return
    
    print(f"{GREEN}Found devices:{RESET}")
    for i, (addr, name) in enumerate(devices):
        print(f"{i+1}. {name} ({addr})")
    
    try:
        choice = int(input(f"\n{YELLOW}Select device to send demo message to (0 to cancel): {RESET}"))
        if choice == 0:
            return
        
        addr, name = devices[choice-1]
        message = "This is a bluejacking demo message from XHarvester"
        
        print_status(f"Sending demo message to {name} ({addr})")
        print(f"{CYAN}Message: {message}{RESET}")
        print()
        print_warning("Note: Actual bluejacking requires specific OBEX protocols and vulnerable devices")
        
    except (ValueError, IndexError):
        print_error("Invalid selection")

def bluesnarfing_info():
    """Information about bluesnarfing"""
    print_status("Bluesnarfing Information")
    print(f"{YELLOW}Bluesnarfing is an attack that extracts information from Bluetooth devices.")
    print(f"It typically targets the OBEX Push Profile to access calendars, contacts, etc.{RESET}")
    print()
    print(f"{RED}WARNING: Bluesnarfing is illegal without explicit permission.{RESET}")
    print(f"{YELLOW}This tool provides information only - not actual attack capabilities.{RESET}")
    print()
    print(f"{GREEN}Vulnerable devices often:{RESET}")
    print(f"  - Have Bluetooth in discoverable mode")
    print(f"  - Use weak or default PINs")
    print(f"  - Have outdated firmware")
    print()
    print(f"{GREEN}Protection measures:{RESET}")
    print(f"  - Keep Bluetooth in non-discoverable mode when not in use")
    print(f"  - Use strong PINs/passkeys")
    print(f"  - Keep devices updated")
    print(f"  - Disable unnecessary Bluetooth services")

async def ble_scan():
    """Scan for BLE devices"""
    if not BLE_AVAILABLE:
        print_error("Bleak library not available")
        print_warning("Install with: pip install bleak")
        return
    
    print_status("Scanning for BLE devices...")
    
    try:
        devices = await BleakScanner.discover(timeout=15.0)
        
        if not devices:
            print_warning("No BLE devices found")
            return
        
        print(f"{GREEN}Found {len(devices)} BLE devices:{RESET}")
        for i, device in enumerate(devices):
            print(f"{i+1}. {device.name} - {device.address}")
            print(f"   RSSI: {device.rssi} dBm")
            print(f"   Details: {device.details}")
            print()
            
    except Exception as e:
        print_error(f"BLE scan failed: {e}")

def run_ble_scan():
    """Run BLE scan in async context"""
    if not BLE_AVAILABLE:
        print_error("BLE functionality not available")
        return
    
    try:
        asyncio.run(ble_scan())
    except Exception as e:
        print_error(f"Error running BLE scan: {e}")

def bluetooth_module():
    clear_screen()
    print_status(f"{CYAN}Initializing Bluetooth module...\n")
    
    # Check if Bluetooth is available
    if not check_bluetooth_dependencies():
        print_error("Bluetooth functionality is not available.")
        print_warning("Please install the required dependencies:")
        print_warning("  pip install pybluez2 bleak")
        input(f"\n{GREEN}Press Enter to continue...{RESET}")
        return
    
    time.sleep(0.05)
    active = True
    while active:
        clear_screen()
        text_animation()
        print(f"\n\t\t\t(▀̿Ĺ̯▀̿ ̿)\t\t\t\n")
        print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
        print(f"{GREEN}         🚀   XHARVESTER -- BLUETOOTH MENU")
        print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
        print(f"{CYAN}\t[1] 📨 Bluejacking Demo")
        print(f"{CYAN}\t[2] ✉️ Bluesnarfing Info")
        print(f"{CYAN}\t[3] 🐛 Bluebugging Info")
        print(f"{CYAN}\t[4] 👂 MITM Attacks Info")
        print(f"{CYAN}\t[5] 🎙️ Car Whisperer Info")
        print(f"{CYAN}\t[6] 🎭 BLE Scanning")
        print(f"{CYAN}\t[7] 📡 Classic BT Scanning")
        print(f"{CYAN}\t[8] 🔍 List Services")
        print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")
        print(f"{YELLOW}\t[0] ⇇ Back")
        print(f"{LIGHTCYAN_EX}  ⇇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━⇉")  

        try:
            choice = input(f"\n  {GREEN}xharvester{YELLOW}@{RESET}{CYAN}{get_hostname()}{RESET}{RED}:{RESET}{GREEN}~{RESET}{YELLOW}$ ")
        except (KeyboardInterrupt, EOFError):
            terminator = f"\n\n\t\t\t{MAGENTA}[💀]{RESET}{RED} Exiting...\n\n"
            for word in terminator:
                print(word, end="", flush=True)
                time.sleep(0.05)
            break
            
        if choice == "0":
            mesg = f"{YELLOW}\n\t\t\tMoving back..."
            for word in mesg:
                print(word, end="", flush=True)
                time.sleep(0.05)
            active = False

        elif choice == "1":
            bluejacking_demo()

        elif choice == "2":
            bluesnarfing_info()

        elif choice == "3":
            print(f"\n{GREEN}  Bluebugging:{CYAN} Gaining unauthorized access to a Bluetooth device.")
            print(f"{GREEN}  Impact:{CYAN} Allows attacker to make calls, send messages, read contacts.")
            print(f"{GREEN}  Protection:{CYAN} Keep devices updated, use non-discoverable mode.{RESET}")
            print(f"{RED}  WARNING: This is illegal without permission.{RESET}\n")

        elif choice == "4":
            print(f"\n{GREEN}  MITM Attacks:{CYAN} Intercepting Bluetooth communication.")
            print(f"{GREEN}  Techniques:{CYAN} Impersonation, encryption downgrade, key negotiation.")
            print(f"{GREEN}  Protection:{CYAN} Use secure pairing, verify devices, monitor connections.{RESET}\n")

        elif choice == "5":
            print(f"\n{GREEN}  Car Whisperer:{CYAN} Attack against vehicle Bluetooth systems.")
            print(f"{GREEN}  Impact:{CYAN} Eavesdrop on conversations or inject audio into the vehicle.")
            print(f"{GREEN}  Protection:{CYAN} Change default PINs, disable Bluetooth when not in use.{RESET}\n")

        elif choice == "6":
            run_ble_scan()

        elif choice == "7":
            devices = discover_classic_devices()
            if devices:
                print(f"{GREEN}Found {len(devices)} classic Bluetooth devices:{RESET}")
                for i, (addr, name) in enumerate(devices):
                    print(f"{i+1}. {name} ({addr})")
            else:
                print_warning("No classic Bluetooth devices found")

        elif choice == "8":
            addr = input(f"{YELLOW}Enter device address to list services: {RESET}")
            if addr:
                list_services(addr)

        else:
            print_error("Invalid option. Please try again.")
        
        if choice != "0":
            input(f"\n{GREEN}Press Enter to continue...{RESET}")

def wifi_module():
    print_status(f"{CYAN}Initializing WiFi module...")
    time.sleep(2)
    print_warning(f"{YELLOW}WiFi module is a placeholder - actual functionality not implemented")
    input(f"\n{GREEN}Press Enter to continue...{RESET}")

def automobile_module():
    print_status(f"{CYAN}Initializing Automobile module...")
    time.sleep(2)
    print_warning(f"{YELLOW}Automobile module is a placeholder - actual functionality not implemented")
    input(f"\n{GREEN}Press Enter to continue...{RESET}")

def rf_module():
    print_status(f"{CYAN}Initializing Radio Frequency module...")
    time.sleep(2)
    print_warning(f"{YELLOW}RF module is a placeholder - actual functionality not implemented")
    input(f"\n{GREEN}Press Enter to continue...{RESET}")

def scada_module():
    print_status(f"{CYAN}Initializing SCADA module...")
    time.sleep(2)
    print_warning(f"{YELLOW}SCADA module is a placeholder - actual functionality not implemented")
    input(f"\n{GREEN}Press Enter to continue...{RESET}")

def run_updater():
    """Run the xharvester_updater.py script as a subprocess"""
    clear_screen()
    
    # Check if updater script exists
    updater_script = "xharvester_updater.py"
    if not os.path.exists(updater_script):
        print_error(f"Updater script '{updater_script}' not found!")
        print_warning("Please ensure xharvester_updater.py is in the same directory.")
        input(f"\n{GREEN}Press Enter to continue...{RESET}")
        return
    
    try:
        # Run the updater script
        print(f"{CYAN}Running XHarvester updater...{RESET}\n")
        result = subprocess.run([sys.executable, updater_script], 
                              capture_output=False, text=True)
        
        if result.returncode == 0:
            print_status("Update completed successfully!")
        else:
            print_error("Update failed or was canceled.")
            
    except KeyboardInterrupt:
        print_error("\nUpdate canceled by user.")
    except Exception as e:
        print_error(f"Error running updater: {e}")
    
    input(f"\n{GREEN}Press Enter to continue...{RESET}")

def main():
    # Check for root privileges
    if not check_root():
        warning = f"{YELLOW}[!] {RESET}{YELLOW}Please run xharvester with administrator/root privileges!\n"
        for word in warning:
            print(word, end='', flush=True)
            time.sleep(0.05)
        
        # Offer to fix desktop launcher if it exists but isn't working
        if check_desktop_launcher():
            response = input(f"\n{GREEN}Would you like to try fixing the desktop launcher? (Y/n): {RESET}")
            if response.lower() not in ['n', 'no']:
                if fix_desktop_launcher():
                    print_status("Desktop launcher fixed. Please try clicking it again.")
                else:
                    print_error("Failed to fix desktop launcher.")
        
        sys.exit(1)
    
    # ========== MAIN LOOP ========== #
    active = True
    while active:
        clear_screen()
        show_menu()
        try:
            choice = input(f"\n  {GREEN}xharvester{YELLOW}@{RESET}{CYAN}{get_hostname()}{RESET}{RED}:{RESET}{GREEN}~{RESET}{YELLOW}$ ")
        except (KeyboardInterrupt, EOFError):
            terminator = f"\n\n\t\t\t{MAGENTA}[💀]{RESET}{RED} Exiting...\n\n"
            for word in terminator:
                print(word, end="", flush=True)
                time.sleep(0.05)
            break
            
        if choice == "0":
            closing_text = f"\n{MAGENTA}[💀] {RESET}{RED}Closing The Program...\n\n"
            for word in closing_text:
                print(word, end='', flush=True)
                time.sleep(0.05)
            active = False
            
        elif choice == "1":
            bluetooth_module()
            
        elif choice == "2":
            wifi_module()

        elif choice == "3":
            automobile_module()

        elif choice == '4':
            rf_module()

        elif choice == '5':
            scada_module()

        elif choice == '6':
            try:
                time_choice = input(f'{GREEN}[?] Choose time stamps [Read Bio & About][default = 10]>>> {RESET}')
                if not time_choice:
                    about()
                    time.sleep(10)
                else:
                    about()
                    time.sleep(int(time_choice))
            except ValueError:
                print_error("Invalid input. Using default time of 10 seconds.")
                time.sleep(10)
            except (KeyboardInterrupt, EOFError):
                print("\n\nReturning to menu...")
                time.sleep(1)

        elif choice == '99':
            run_updater()

        else:
            warning = f"\n\t'{choice}' is not a valid menu option!\n"
            print(warning)
            time.sleep(2)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt as err:
        varerr = f"\n\n\t\t\t{MAGENTA}{err}[💀] {RESET}{RED}Process Terminated by User\n\n"
        for word in varerr:
            print(word, end="", flush=True)
            time.sleep(0.05)